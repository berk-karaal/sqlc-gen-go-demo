// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: db/sqlcrepo/batch.go

package sqlcrepo

import (
	"context"
	"errors"

	"github.com/berk-karaal/sqlc-gen-go-demo/development-testing/internal/business/entities"
	"github.com/jackc/pgx/v5"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const batchRetrieveOrderStatus = `-- name: BatchRetrieveOrderStatus :batchone
SELECT status FROM orders WHERE id = $1
`

type BatchRetrieveOrderStatusBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

// 10. Batch query return enum example
func (q *Queries) BatchRetrieveOrderStatus(ctx context.Context, id []int32) *BatchRetrieveOrderStatusBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(batchRetrieveOrderStatus, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &BatchRetrieveOrderStatusBatchResults{br, len(id), false}
}

func (b *BatchRetrieveOrderStatusBatchResults) QueryRow(f func(int, entities.OrderStatus, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var status entities.OrderStatus
		if b.closed {
			if f != nil {
				f(t, status, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&status)
		if f != nil {
			f(t, status, err)
		}
	}
}

func (b *BatchRetrieveOrderStatusBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const batchRetrieveOrderStatusAndTotal = `-- name: BatchRetrieveOrderStatusAndTotal :batchone
SELECT status, total FROM orders WHERE id = $1
`

type BatchRetrieveOrderStatusAndTotalBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type BatchRetrieveOrderStatusAndTotalRow struct {
	Status entities.OrderStatus
	Total  int32
}

// 11. Batch query return enum inside return struct example
func (q *Queries) BatchRetrieveOrderStatusAndTotal(ctx context.Context, id []int32) *BatchRetrieveOrderStatusAndTotalBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(batchRetrieveOrderStatusAndTotal, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &BatchRetrieveOrderStatusAndTotalBatchResults{br, len(id), false}
}

func (b *BatchRetrieveOrderStatusAndTotalBatchResults) QueryRow(f func(int, BatchRetrieveOrderStatusAndTotalRow, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i BatchRetrieveOrderStatusAndTotalRow
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&i.Status, &i.Total)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *BatchRetrieveOrderStatusAndTotalBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const batchRetrieveOrders = `-- name: BatchRetrieveOrders :batchone
SELECT id, user_id, total, status FROM orders WHERE id = $1
`

type BatchRetrieveOrdersBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

// 9. Batch query return model struct example
func (q *Queries) BatchRetrieveOrders(ctx context.Context, id []int32) *BatchRetrieveOrdersBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(batchRetrieveOrders, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &BatchRetrieveOrdersBatchResults{br, len(id), false}
}

func (b *BatchRetrieveOrdersBatchResults) QueryRow(f func(int, entities.Order, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i entities.Order
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.UserID,
			&i.Total,
			&i.Status,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *BatchRetrieveOrdersBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const batchUpdateOrderStatus = `-- name: BatchUpdateOrderStatus :batchexec
UPDATE orders SET status = $1 WHERE id = $2
`

type BatchUpdateOrderStatusBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type BatchUpdateOrderStatusParams struct {
	Status entities.OrderStatus
	ID     int32
}

// 8. Batch query enum inside argument struct example
func (q *Queries) BatchUpdateOrderStatus(ctx context.Context, arg []BatchUpdateOrderStatusParams) *BatchUpdateOrderStatusBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Status,
			a.ID,
		}
		batch.Queue(batchUpdateOrderStatus, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &BatchUpdateOrderStatusBatchResults{br, len(arg), false}
}

func (b *BatchUpdateOrderStatusBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *BatchUpdateOrderStatusBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
